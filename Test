@Test
void testFilterPlans_WithAllConditionsMet() throws Exception {
    // Set up the preAuthHeadersMap with valid data
    Map<String, String> preAuthHeadersMap = Map.of(
        "UC_VENDOR_ID", "SPSRWB", // Vendor ID must match
        "UC_PLAN_ID_LIST", "plan1,plan2" // Valid plan list
    );
    String clientId = "client123";

    // Mock DocumentInfo and MailInfo with different planIds
    DocumentInfo doc1 = mock(DocumentInfo.class);
    DocumentInfo doc2 = mock(DocumentInfo.class);
    DocumentInfo doc3 = mock(DocumentInfo.class);

    when(doc1.getPlanId()).thenReturn("plan1"); // Valid planId from the map
    when(doc2.getPlanId()).thenReturn("plan3"); // Invalid planId
    when(doc3.getPlanId()).thenReturn("plan2"); // Valid planId from the map

    // Mock MailInfo containing the DocumentInfo objects
    MailInfo mailInfo = mock(MailInfo.class);
    when(mailInfo.getDocumentInfo()).thenReturn(List.of(doc1, doc2, doc3));

    List<MailInfo> mailInfoList = List.of(mailInfo);

    // Access private method filterPlans using reflection
    Method filterPlansMethod = MailItConfirmCorrespondenceService.class.getDeclaredMethod(
        "filterPlans", List.class, Map.class, String.class
    );
    filterPlansMethod.setAccessible(true);

    // Invoke the private method with reflection
    List<MailInfo> result = (List<MailInfo>) filterPlansMethod.invoke(service, mailInfoList, preAuthHeadersMap, clientId);

    // Debugging: Print the result
    System.out.println("Filtered MailInfo List Size: " + result.size());
    result.forEach(mailInfoResult -> {
        System.out.println("MailInfo Document Size: " + mailInfoResult.getDocumentInfo().size());
        mailInfoResult.getDocumentInfo().forEach(doc -> {
            System.out.println("Document PlanId: " + doc.getPlanId());
        });
    });

    // Verify that only documents with plan1 and plan2 are present
    assertNotNull(result);
    assertEquals(1, result.size(), "There should be one MailInfo object remaining.");
    List<DocumentInfo> filteredDocuments = result.get(0).getDocumentInfo();
    assertEquals(2, filteredDocuments.size(), "There should be exactly two documents with valid plan IDs.");

    // Check that only the documents with matching planIds remain
    assertTrue(filteredDocuments.stream().anyMatch(doc -> "plan1".equals(doc.getPlanId())), "plan1 should be included.");
    assertTrue(filteredDocuments.stream().anyMatch(doc -> "plan2".equals(doc.getPlanId())), "plan2 should be included.");
    assertFalse(filteredDocuments.stream().anyMatch(doc -> "plan3".equals(doc.getPlanId())), "plan3 should not be included.");

    // Extra assertion to check the filtering logic explicitly
    List<String> globalPlanList = Arrays.asList(StringUtils.split(preAuthHeadersMap.get("UC_PLAN_ID_LIST"), ","));
    filteredDocuments.forEach(doc -> {
        assertTrue(globalPlanList.contains(doc.getPlanId()), "Document planId should be in the global plan list.");
    });
}
