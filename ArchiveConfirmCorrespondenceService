@Service
@Slf4j
public class CombineConfirmCorrespondenceService {
    private final ArchiveDocsRestService archiveDocsRestService;
    private final MailItPreferenceService mailItPreferenceService;
    private final SetItPullClientCache setItPullClientCache;
    private final RequestService requestService;
    private final ClientParticipantInfoCache clientParticipantInfoCache;

    @Autowired
    @Qualifier("asyncExecutor")
    private Executor correspondenceExecutor;

    CombineConfirmCorrespondenceService(final ClientParticipantInfoCache clientParticipantInfoCache,
                                        final ArchiveDocsRestService archiveDocsRestService,
                                        final MailItPreferenceService mailItPreferenceService,
                                        final RequestService requestService, final SetItPullClientCache setItPullClientCache) {
        this.archiveDocsRestService = archiveDocsRestService;
        this.mailItPreferenceService = mailItPreferenceService;
        this.setItPullClientCache = setItPullClientCache;
        this.clientParticipantInfoCache = clientParticipantInfoCache;
        this.requestService = requestService;

    }

    public CorrespondenceResponse getCorrespondenceDocs(final Map<String, String> reqHeadersMap,
                                                        final PartyInfo partyInfo) {
        final Map<String, String> preAuthHeadersMap = requestService.getPreAuthHeadersMap(reqHeadersMap);
        Party party = Party.builder().partyId(partyInfo.getPartyId()).pptId(partyInfo.getSsn()).build();
        final List<Account> accountsList = requestService.getAccountsList(party, preAuthHeadersMap);

        final List<Plan> planInfoList = accountsList.stream()
                .filter(account -> (CrspConstants.SAVINGS.equalsIgnoreCase(account.getPlanType()) || BooleanUtils.isFalse(account.isVoyaAccessPlan())))
                .map(acct -> {
                            Plan plan = new Plan();
                            BeanUtils.copyProperties(acct, plan);
                            return plan;
                        }
                )
                .collect(Collectors.toList());
        List<Plan> plansList = filterPlans(planInfoList, preAuthHeadersMap);
        List<ComboCorresInfo> comboMailList = null;
        if (!CollectionUtils.isEmpty(plansList)) {
            log.debug("getMailitArchiveDocsList() participant = {}  belonging to client = {} has saving plan list size = {}",
                    party.getPptId(), partyInfo.getClientId(), planInfoList.size());
            try {
                comboMailList = buildMailitArchiveDocsList(partyInfo, plansList);
            } catch (Exception e) {
                log.error("Error retrieving the Docs from DocArchive", e);
            }

        } else {
            log.debug("getMailitArchiveDocsList() participant = {}  belonging to client = {} " + " has saving plan list size = null or 0 ",
                    party.getPptId(), partyInfo.getClientId());
        }


        return CorrespondenceResponse.builder().usePlanLvlBrand(setPlanLvlBrandFlg(partyInfo))
                .comboCorresInfos(comboMailList).build();
    }

    private List<ComboCorresInfo> buildMailitArchiveDocsList(final PartyInfo partyInfo, final List<Plan> planList) {

        MailFolder mailFolder;

        Client client = setItPullClientCache.getClient(partyInfo.getClientId());

        boolean doesIncludeMigrated = true;
        if ("CEDARARCHIVEECOR".equalsIgnoreCase(client.getConfirmSource())) {
            doesIncludeMigrated = false;
        }


        log.debug("buildMailitArchiveDocsList(): Get documents for ParticipantId [{}] clientId [{}] includeMigrated [{}]",
                FormatUtil.getParticipantMasked(partyInfo.getSsn()), client.getClientId(), doesIncludeMigrated);

        List<ArchiveDocsInfo> archiveDocsInfoList;
        try {
            List<String> planIds = planList.stream().map(Plan::getPlanId).collect(Collectors.toList());
            StopWatch docArchiveStopWatch = new StopWatch();
            docArchiveStopWatch.start();
            // Get confirm documents from DocArchive location
            boolean finalDoesIncludeMigrated = doesIncludeMigrated;
            List<CompletableFuture<List<ArchiveDocsInfo>>> completableFutureArchiveDocList =
                    planList.stream().map(plan -> CompletableFuture.supplyAsync(() ->
                            archiveDocsRestService.getEaseCorrespondenceDocList(partyInfo.getSsn(), plan, finalDoesIncludeMigrated), correspondenceExecutor))
                            .collect(Collectors.toList());

            archiveDocsInfoList = completableFutureArchiveDocList.stream().flatMap(completableFuture -> completableFuture.join().stream())
                    .collect(Collectors.toList());

            if (!archiveDocsInfoList.isEmpty() || docArchiveStopWatch.isRunning()) {
                docArchiveStopWatch.stop();
                log.debug("buildMailitArchiveDocsList(): {} Processed docarchive future successfully in {} s",
                        Thread.currentThread().getName(), docArchiveStopWatch.getTotalTimeSeconds());
            }

            // Get confirm documents from netApp location
            StopWatch mailItStopWatch = new StopWatch();
            mailItStopWatch.start();
            CompletableFuture<MailFolder> mailFolderCompletableFuture = invokeMailIt(client.getClientId(), partyInfo.getSsn(), planIds, doesIncludeMigrated);

            log.debug("buildMailitArchiveDocsList(): Processing response for ParticipantId [{}] clientId [{}]",
                    FormatUtil.getParticipantMasked(partyInfo.getSsn()), client.getClientId());
            mailFolder = mailFolderCompletableFuture.get();


            if (mailFolder != null || mailItStopWatch.isRunning()) {
                mailItStopWatch.stop();
                log.debug("buildMailitArchiveDocsList(): {} Processed netapp future successfully in {} s",
                        Thread.currentThread().getName(), mailItStopWatch.getTotalTimeSeconds());
            }
        } catch (Exception exc) {
            throw new RestClientApiException(ExceptionTypeEnum.SERVICE_ERROR, "excepiton while processing docArchive/Mailit", exc);
        }

        return makeComboMailBox(planList, archiveDocsInfoList, mailFolder);
    }

    private CompletableFuture<MailFolder> invokeMailIt(String clientId, String participantId, List<String> planIds, boolean finalDoesIncludeMigrated) {
        log.debug("buildMailitArchiveDocsList(): Processing to fetch NetApp server List for ParticipantId [{}] clientId [{}]",
                FormatUtil.getParticipantMasked(participantId), clientId);
        log.info("hre thread check");
        CompletableFuture<MailFolder> mailFolderCompletableFuture;
        if (finalDoesIncludeMigrated) {
            mailFolderCompletableFuture = CompletableFuture.supplyAsync(() -> mailItPreferenceService.getCombinedMailFolder(clientId, participantId, planIds, DocumentType.PREFILLED,
                    DocumentType.CONFIRM, DocumentType.EDELIVERYUPDATE), correspondenceExecutor);
        } else {
            mailFolderCompletableFuture = CompletableFuture.supplyAsync(() -> mailItPreferenceService.getCombinedMailFolder(clientId, participantId, planIds, DocumentType.CONFIRM,
                    DocumentType.EDELIVERYUPDATE), correspondenceExecutor);
        }
        log.info("Exit thread check");
        return mailFolderCompletableFuture;
    }


    private List<ComboCorresInfo> makeComboMailBox(List<Plan> planList, List<ArchiveDocsInfo> archiveDocInfoList, MailFolder mdoc) {
        List<ComboCorresInfo> comboList = new ArrayList<>();

        if (CollectionUtils.isNotEmpty(archiveDocInfoList)) {
            archiveDocInfoList.forEach(doc ->
                    comboList.add(new ComboCorresInfo(false, doc.getPlanNo(), doc.getPlanName(), doc.getSysDocName(),
                            doc.getUserDocName(), doc.getRunDate(), doc.getTransactionDate(), doc.getDocQueryParamValue(),
                            doc.getDocQueryParamName(), doc.getDocViewURL())));
        }

        if (mdoc != null && CollectionUtils.isNotEmpty(mdoc.getMailInfo())) {
            for (MailInfo mInfo : mdoc.getMailInfo()) {
                SimpleDateFormat sdf = new SimpleDateFormat("MM/dd/yyyy");
                String transactionDate = sdf.format(mInfo.getBeginDate().toGregorianCalendar().getTime());
                if (mInfo.getDocumentInfo() != null) {
                    for (DocumentInfo doc : mInfo.getDocumentInfo()) {

                        comboList.add(new ComboCorresInfo(true, doc.getPlanId(), getPlanName(planList, doc.getPlanId()),
                                doc.getSysDocName(), doc.getUserDocName(), null, transactionDate, doc.getMessageId(),
                                doc.getDocumentId()));
                    }
                }
            }

        }
        if (!comboList.isEmpty()) {
            Collections.sort(comboList);
        }
        return Collections.unmodifiableList(comboList);
    }

    private String getPlanName(List<Plan> planList, String planId) {
        return planList.stream().filter(plan -> plan.getPlanId().equalsIgnoreCase(planId)).
                map(Plan::getPlanName).findFirst().orElse(StringUtils.EMPTY);
    }

    private List<Plan> filterPlans(final List<Plan> planInfoList, Map<String, String> preAuthHeadersMap) {
        if (MapUtils.isNotEmpty(preAuthHeadersMap) && CrspConstants.SPSRWB.equalsIgnoreCase(preAuthHeadersMap.get(CrspConstants.UC_VENDOR_ID))
                && null != preAuthHeadersMap.get(CrspConstants.UC_PLAN_ID_LIST)) {

            List<String> globalPlanList = List.of(StringUtils.split(preAuthHeadersMap.get(CrspConstants.UC_PLAN_ID_LIST), ","));

            return planInfoList.stream().filter(plan -> globalPlanList.contains(plan.getPlanId())).collect(Collectors.toList());

        }
        return planInfoList;
    }

    public boolean setPlanLvlBrandFlg(final PartyInfo partyInfo) {
        List<String> planList = clientParticipantInfoCache.getAllPlansByClientParticipantControlType(partyInfo.getClientId(), partyInfo.getSsn(),
                ControlType.WEB);
        if (CollectionUtils.isNotEmpty(planList)) {
            Plan plan = Plan.builder().clientId(partyInfo.getClientId())
                    .planId(planList.get(0)).build();
            PlanGeneralInfo planGeneralInfo = setItPullClientCache.getSetItPlanGeneralInfo(plan);
            return "Y".equalsIgnoreCase(planGeneralInfo.getUsePlanLevelCustomBranding());
        }
        return false;
    }

}
