@Slf4j
@Service
public class ArchiveConfirmCorrespondenceService {
    private final ArchiveDocsRestService archiveDocsRestService;
    private final RequestService requestService;
    private final Executor correspondenceExecutor;
    private final ClientParticipantInfoCache clientParticipantInfoCache;
    private final SetItPullClientCache setItPullClientCache;

    ArchiveConfirmCorrespondenceService(final ArchiveDocsRestService archiveDocsRestService,
                                        final RequestService requestService,

                                        final ClientParticipantInfoCache clientParticipantInfoCache,
                                        final SetItPullClientCache setItPullClientCache,
                                        @Qualifier("asyncExecutor") final Executor correspondenceExecutor) {
        this.archiveDocsRestService = archiveDocsRestService;
        this.requestService = requestService;
        this.clientParticipantInfoCache = clientParticipantInfoCache;
        this.setItPullClientCache = setItPullClientCache;
        this.correspondenceExecutor = correspondenceExecutor;
    }

    public CorrespondenceResponse getCorrespondenceDocs(final Map<String, String> reqHeadersMap,
                                                        final PartyInfo partyInfo) {


        final Map<String, String> preAuthHeadersMap = requestService.getPreAuthHeadersMap(reqHeadersMap);
        Party party = Party.builder().partyId(partyInfo.getPartyId()).pptId(partyInfo.getSsn()).build();
        final List<Account> accountsList = requestService.getAccountsList(party, preAuthHeadersMap);

        final List<Plan> planInfoList = accountsList.stream()
                .filter(account -> CrspConstants.SAVINGS.equalsIgnoreCase(account.getPlanType()) || BooleanUtils.isFalse(account.isVoyaAccessPlan()))
                .map(acct -> {
                            Plan plan = new Plan();
                            BeanUtils.copyProperties(acct, plan);
                            return plan;
                        }
                ).collect(Collectors.toList());

        List<ArchiveDocsInfo> archiveDocInfoList = new ArrayList<>();
        if (!CollectionUtils.isEmpty(planInfoList)) {
            List<Plan> filterPlansList = filterPlans(planInfoList, preAuthHeadersMap);
            log.debug("getCorresArchDocsList() participant = {}  belonging to client = {} has saving plan list size = {} ",
                    party.getPptId(), partyInfo.getClientId(), filterPlansList.size());
            try {
                List<CompletableFuture<List<ArchiveDocsInfo>>> completableFutureArchiveDocList =
                        filterPlansList.stream().map(plan -> CompletableFuture.supplyAsync(() ->
                                archiveDocsRestService.getEaseCorrespondenceDocList(partyInfo.getSsn(), plan, Boolean.TRUE), correspondenceExecutor))
                                .collect(Collectors.toList());
                archiveDocInfoList = completableFutureArchiveDocList.stream().flatMap(completableFuture -> completableFuture.join().stream())
                        .collect(Collectors.toList());
                Collections.sort(archiveDocInfoList);
            } catch (Exception e) {
                log.error("getCorresArchDocsList() Error retrieving the Docs from DocArchive :: ", e);
            }

        } else {
            log.debug(" participant = {}  belonging to client = {} " + " has saving plan list size = null or 0 ",
                    party.getPptId(), partyInfo.getClientId());
        }

        return CorrespondenceResponse.builder().usePlanLvlBrand(setPlanLvlBrandFlg(partyInfo))
                .archiveDocsInfos(Collections.unmodifiableList(archiveDocInfoList)).build();
    }


    private List<Plan> filterPlans(final List<Plan> planInfoList, Map<String, String> preAuthHeadersMap) {
        if (MapUtils.isNotEmpty(preAuthHeadersMap) && CrspConstants.SPSRWB.equalsIgnoreCase(preAuthHeadersMap.get(CrspConstants.UC_VENDOR_ID))
                && null != preAuthHeadersMap.get(CrspConstants.UC_PLAN_ID_LIST)) {

            List<String> globalPlanList = List.of(StringUtils.split(preAuthHeadersMap.get(CrspConstants.UC_PLAN_ID_LIST), ","));

            return planInfoList.stream().filter(plan -> globalPlanList.contains(plan.getPlanId())).collect(Collectors.toList());

        }
        return planInfoList;
    }

    public boolean setPlanLvlBrandFlg(final PartyInfo partyInfo) {
        List<String> planList = clientParticipantInfoCache.getAllPlansByClientParticipantControlType(partyInfo.getClientId(), partyInfo.getSsn(),
                ControlType.WEB);
        if (CollectionUtils.isNotEmpty(planList)) {
            Plan plan = Plan.builder().planId(planList.get(0)).clientId(partyInfo.getClientId()).build();
            PlanGeneralInfo planGeneralInfo = setItPullClientCache.getSetItPlanGeneralInfo(plan);
            return "Y".equalsIgnoreCase(planGeneralInfo.getUsePlanLevelCustomBranding());
        }
        return false;
    }
}
